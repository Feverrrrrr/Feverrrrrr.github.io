<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¦å…‹å¯¹å†³ - æœ¬åœ°/è”æœºåŒäººæ¸¸æˆ</title>
    <!-- æ·»åŠ PeerJSåº“ -->
    <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(to bottom, #0f0c29, #302b63, #24243e);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }
        header { text-align: center; margin-bottom: 20px; }
        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(to right, #ff7e5f, #feb47b);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 5px 15px rgba(255, 126, 95, 0.3);
        }
        .subtitle { 
            color: #a0aec0; 
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        /* è”æœºé¢æ¿æ ·å¼ */
        #networkPanel {
            background: rgba(0, 0, 0, 0.8); 
            padding: 20px; 
            border-radius: 10px; 
            margin: 20px auto; 
            max-width: 500px; 
            width: 100%;
            text-align: center;
            border: 2px solid #00dbde;
            box-shadow: 0 0 20px rgba(0, 219, 222, 0.3);
        }
        #connectionStatus {
            margin: 15px 0; 
            padding: 12px; 
            background: #2a2a4a; 
            border-radius: 5px;
            font-size: 1.1rem;
            min-height: 20px;
        }
        .network-buttons {
            display: flex; 
            gap: 10px; 
            justify-content: center; 
            margin: 15px 0;
        }
        .network-buttons button {
            padding: 12px 24px; 
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        #hostBtn { background: #38b2ac; color: white; }
        #joinBtn { background: #9f7aea; color: white; }
        #roomSection { display: none; margin-top: 15px; }
        #roomIdInput {
            padding: 10px; 
            width: 200px; 
            border-radius: 5px; 
            border: 2px solid #4fd1c7; 
            background: #1a1a2e; 
            color: white;
            font-size: 1rem;
        }
        #connectBtn {
            padding: 10px 20px; 
            background: #00dbde; 
            color: white; 
            border: none; 
            border-radius: 5px; 
            margin-left: 10px; 
            cursor: pointer;
            font-weight: bold;
        }
        #roomInfo {
            margin-top: 10px; 
            padding: 12px; 
            background: #1a1a2e; 
            border-radius: 5px;
            line-height: 1.5;
        }
        .score-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }
        #score {
            font-size: 2rem;
            padding: 12px 35px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 50px;
            border: 2px solid #00dbde;
            box-shadow: 0 0 15px rgba(0, 219, 222, 0.5);
            display: inline-block;
        }
        #bulletCount {
            font-size: 1.2rem;
            padding: 8px 25px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 30px;
            border: 1px solid #4a5568;
            display: flex;
            gap: 20px;
        }
        .bullet-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .bullet-icon {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        .bullet-icon.red { background-color: #FF6B6B; }
        .bullet-icon.blue { background-color: #4ECDC4; }
        .highlight { 
            color: #00dbde; 
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 219, 222, 0.7);
        }
        .container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 30px;
            max-width: 1300px;
            width: 100%;
        }
        #gameCanvas {
            background-color: #0a0a1a;
            border-radius: 12px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.8);
            border: 4px solid #4a5568;
            image-rendering: crisp-edges;
        }
        .panel {
            background: rgba(20, 25, 45, 0.85);
            padding: 25px;
            border-radius: 15px;
            min-width: 300px;
            border: 1px solid #3a506b;
            backdrop-filter: blur(5px);
        }
        .panel h3 {
            color: #6ee7b7;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3a506b;
            font-size: 1.5rem;
        }
        .controls-list {
            list-style: none;
            margin-bottom: 25px;
        }
        .controls-list li {
            margin-bottom: 15px;
            padding: 15px;
            background: linear-gradient(90deg, rgba(45, 55, 72, 0.7), rgba(30, 40, 60, 0.7));
            border-radius: 10px;
            border-left: 5px solid #4299e1;
            transition: transform 0.2s;
        }
        .controls-list li:hover { transform: translateX(5px); }
        .controls-list kbd {
            background: #2d3748;
            padding: 4px 10px;
            border-radius: 6px;
            font-family: monospace;
            border: 1px solid #4a5568;
            margin: 0 4px;
            box-shadow: 0 2px 0 #1a202c;
        }
        .button-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 10px;
        }
        button {
            background: linear-gradient(to right, #38b2ac, #319795);
            color: white;
            border: none;
            padding: 16px;
            font-size: 1.1rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        button:hover { 
            background: linear-gradient(to right, #319795, #2c7a7b); 
            transform: translateY(-3px);
            box-shadow: 0 7px 14px rgba(50, 151, 149, 0.4);
        }
        button#soundBtn { background: linear-gradient(to right, #ed8936, #dd6b20); }
        button#soundBtn:hover { background: linear-gradient(to right, #dd6b20, #c05621); }
        button#newMapBtn { background: linear-gradient(to right, #9f7aea, #805ad5); }
        button#newMapBtn:hover { background: linear-gradient(to right, #805ad5, #6b46c1); }
        .rules p { margin-bottom: 12px; line-height: 1.7; }
        .update-note {
            background: rgba(255, 193, 7, 0.1);
            border-left: 5px solid #ffc107;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        footer {
            margin-top: 40px;
            color: #718096;
            text-align: center;
            font-size: 0.9rem;
            width: 100%;
        }
        @media (max-width: 1000px) {
            .container { flex-direction: column; align-items: center; }
            #gameCanvas { width: 95% !important; height: auto !important; }
            .network-buttons { flex-direction: column; }
        }
    </style>
</head>
<body>
    <header>
        <h1>ğŸ’¥ å¦å…‹å¯¹å†³ â™‚</h1>
        <p class="subtitle">è¾“çš„äººæ˜¯GAY</p>
        
        <!-- è”æœºå¯¹æˆ˜é¢æ¿ -->
        <div id="networkPanel">
            <h3>ğŸ•¸ï¸ è”æœºå¯¹æˆ˜</h3>
            
            <div id="connectionStatus">
                å½“å‰ï¼š<span style="color:#4fd1c7">ç­‰å¾…è¿æ¥...</span>
            </div>
            
            <div class="network-buttons">
                <button id="hostBtn">ğŸ® åˆ›å»ºæˆ¿é—´</button>
                <button id="joinBtn">ğŸ”— åŠ å…¥æˆ¿é—´</button>
            </div>
            
            <div id="roomSection">
                <div style="margin:10px 0;">
                    <input type="text" id="roomIdInput" placeholder="è¾“å…¥æˆ¿é—´ID">
                    <button id="connectBtn">è¿æ¥</button>
                </div>
                <div id="roomInfo"></div>
            </div>
            
            <div style="margin-top:15px; font-size:0.9rem; color:#a0aec0;">
                <p>ä¸è”æœºï¼Ÿç›´æ¥å¼€å§‹æœ¬åœ°åŒäººå¯¹æˆ˜ï¼</p>
            </div>
        </div>
        
        <!-- æ¸¸æˆåˆ†æ•°å’Œå­å¼¹æ•° -->
        <div class="score-container">
            <div id="score">çº¢: <span id="score1">0</span> | è“: <span id="score2">0</span></div>
            <div id="bulletCount">
                <div class="bullet-info">
                    <div class="bullet-icon red"></div>
                    <span>çº¢æ–¹å­å¼¹: <span id="bulletCount1">0</span>/30</span>
                </div>
                <div class="bullet-info">
                    <div class="bullet-icon blue"></div>
                    <span>è“æ–¹å­å¼¹: <span id="bulletCount2">0</span>/30</span>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>

        <div class="panel">
            <h3>ğŸ® æ“ä½œä¸æ§åˆ¶</h3>
            <ul class="controls-list">
                <li><strong>çº¢è‰²å¦å…‹ (ç©å®¶1)</strong><br>ç§»åŠ¨: <kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> | å¼€ç«: <kbd>F</kbd></li>
                <li><strong>è“è‰²å¦å…‹ (ç©å®¶2)</strong><br>ç§»åŠ¨: <kbd>â†‘</kbd> <kbd>â†“</kbd> <kbd>â†</kbd> <kbd>â†’</kbd> | å¼€ç«: <kbd>M</kbd></li>
                <li><strong>é‡ç½®æ§åˆ¶</strong><br>å›åˆé‡ç½®: <kbd>ç©ºæ ¼</kbd> (ä»»ä½•æ—¶å€™) | æ¸¸æˆé‡ç½®: å¾—åˆ†5åˆ†åæŒ‰ <kbd>ç©ºæ ¼</kbd></li>
                <li><strong>è”æœºæ§åˆ¶</strong><br>ä¸»æœºæ§åˆ¶çº¢å¦å…‹ | å®¢æˆ·ç«¯æ§åˆ¶è“å¦å…‹</li>
            </ul>
            <div class="button-group">
                <button id="restartBtn">ğŸ”„ é‡æ–°å¼€å§‹æ¸¸æˆ</button>
                <button id="newMapBtn">ğŸ—ºï¸ éšæœºç”Ÿæˆæ–°åœ°å›¾</button>
                <button id="soundBtn">ğŸ”Š éŸ³æ•ˆå¼€å¯ä¸­</button>
            </div>
        </div>

        <div class="panel">
            <h3>ğŸ“œ æ¸¸æˆè¯´æ˜</h3>
            <div class="rules">
                <p><span class="highlight">ç‰ˆæœ¬ 2.0 è¯´æ˜ï¼š</span></p>
                <p>1. <strong>å­å¼¹æ•°é‡é™åˆ¶</strong>ï¼šæ¯æ–¹æœ€å¤šåªèƒ½æœ‰<b>30å‘</b>å­å¼¹åœ¨åœºï¼Œè¶…è¿‡æ—¶è‡ªåŠ¨æ¸…é™¤æœ€æ—©å‘å°„çš„å­å¼¹ã€‚</p>
                <p>2. <strong>å­å¼¹æ•°é‡å®æ—¶æ˜¾ç¤º</strong>ï¼šåœ¨åˆ†æ•°ä¸‹æ–¹å®æ—¶æ˜¾ç¤ºåŒæ–¹å½“å‰åœ¨åœºå­å¼¹æ•°ã€‚</p>
                <p>3. <strong>è”æœºå¯¹æˆ˜åŠŸèƒ½</strong>ï¼šä½¿ç”¨PeerJSæŠ€æœ¯ï¼Œæ— éœ€æœåŠ¡å™¨å³å¯è¿œç¨‹è”æœºã€‚</p>
                
                <div class="update-note">
                    <p><strong>ğŸ’ æ¸¸æˆæç¤ºï¼š</strong></p>
                    <p>â€¢ æ³¨æ„å­å¼¹æ•°é‡é™åˆ¶ï¼Œåˆç†æ§åˆ¶å°„å‡»é¢‘ç‡ï¼</p>
                    <p>â€¢ æ­»äº¡åæŒ‰ç©ºæ ¼é”®å¯ç«‹å³é‡æ–°å¼€å§‹å½“å‰å›åˆã€‚</p>
                    <p>â€¢ æ¸¸æˆç»“æŸåæŒ‰ç©ºæ ¼é”®å¯é‡ç½®æ•´ä¸ªæ¸¸æˆã€‚</p>
                    <p>â€¢ è”æœºæ—¶ï¼šä¸»æœºæ§åˆ¶çº¢å¦å…‹ï¼Œå®¢æˆ·ç«¯æ§åˆ¶è“å¦å…‹ã€‚</p>
                    <p>â€¢ è”æœºæ—¶ï¼šåªæœ‰ä¸»æœºå¯ä»¥é€šè¿‡ç©ºæ ¼é”®é‡ç½®ã€‚</p>
                </div>
            </div>
        </div>
    </div>

    <footer>
        <p>å¦å…‹å¯¹å†³æ¸¸æˆ Â© 2025 | è®¾è®¡ï¼šCialloï½(âˆ ãƒ»Ï‰ï¼œ )âŒ’â˜… | æ”¯æŒæœ¬åœ°/è”æœºåŒäººæ¸¸æˆ</p>
    </footer>

    <script>
        // ============== ç½‘ç»œè”æœºæ¨¡å— ==============
        class SimpleNetwork {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.myId = null;
                this.isHost = false;
                this.connected = false;
                this.lastSyncTime = 0;
            }
            
            init() {
                try {
                    // åˆ›å»ºPeerå®ä¾‹ï¼ˆä½¿ç”¨å…è´¹PeerJSæœåŠ¡å™¨ï¼‰
                    this.peer = new Peer({
                        host: '0.peerjs.com',
                        port: 443,
                        path: '/',
                        secure: true,
                        debug: 1
                    });
                    
                    // è·å–è‡ªå·±çš„ID
                    this.peer.on('open', (id) => {
                        this.myId = id;
                        document.getElementById('connectionStatus').innerHTML = 
                            `æˆ‘çš„ID: <span style="color:#ff7e5f">${id}</span>`;
                        console.log('PeerJSå·²è¿æ¥ï¼Œæˆ‘çš„ID:', id);
                    });
                    
                    // å¤„ç†å…¶ä»–ç©å®¶è¿æ¥ï¼ˆä¸»æœºï¼‰
                    this.peer.on('connection', (conn) => {
                        console.log('æœ‰ç©å®¶å°è¯•è¿æ¥');
                        this.conn = conn;
                        this.setupConnection();
                        this.isHost = true;
                        this.connected = true;
                        this.updateUI();
                        console.log('ç©å®¶å·²åŠ å…¥ï¼');
                    });
                    
                    // é”™è¯¯å¤„ç†
                    this.peer.on('error', (err) => {
                        console.error('ç½‘ç»œé”™è¯¯:', err);
                        let errorMsg = err.type;
                        if (err.type === 'peer-unavailable') {
                            errorMsg = 'å¯¹æ–¹IDä¸å­˜åœ¨æˆ–å·²ç¦»çº¿';
                        } else if (err.type === 'network') {
                            errorMsg = 'ç½‘ç»œè¿æ¥é—®é¢˜ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ';
                        }
                        document.getElementById('connectionStatus').innerHTML = 
                            `é”™è¯¯: <span style="color:#ff6b6b">${errorMsg}</span>`;
                    });
                    
                    // æ–­å¼€è¿æ¥
                    this.peer.on('disconnected', () => {
                        console.log('PeerJSè¿æ¥æ–­å¼€');
                        this.connected = false;
                        document.getElementById('connectionStatus').innerHTML = 
                            `<span style="color:#ff6b6b">âŒ è¿æ¥æ–­å¼€ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•</span>`;
                    });
                    
                } catch (error) {
                    console.error('åˆå§‹åŒ–PeerJSå¤±è´¥:', error);
                    document.getElementById('connectionStatus').innerHTML = 
                        `åˆå§‹åŒ–å¤±è´¥: <span style="color:#ff6b6b">è¯·åˆ·æ–°é¡µé¢é‡è¯•</span>`;
                }
            }
            
            // è¿æ¥åˆ°å…¶ä»–ç©å®¶
            connectTo(peerId) {
                if (!peerId || peerId.trim() === '') {
                    document.getElementById('roomInfo').innerHTML += 
                        '<br><span style="color:#ff6b6b">è¯·è¾“å…¥æœ‰æ•ˆçš„æˆ¿é—´ID</span>';
                    return;
                }
                
                console.log('æ­£åœ¨è¿æ¥åˆ°:', peerId);
                document.getElementById('roomInfo').innerHTML = 
                    `æ­£åœ¨è¿æ¥åˆ° <span style="color:#4fd1c7">${peerId}</span>...`;
                
                try {
                    this.conn = this.peer.connect(peerId, {
                        reliable: true
                    });
                    
                    this.setupConnection();
                    this.isHost = false;
                    this.connected = true;
                    this.updateUI();
                    
                    // è®¾ç½®è¶…æ—¶æ£€æµ‹
                    setTimeout(() => {
                        if (!this.conn.open) {
                            document.getElementById('roomInfo').innerHTML += 
                                '<br><span style="color:#ff6b6b">è¿æ¥è¶…æ—¶ï¼Œè¯·æ£€æŸ¥IDæ˜¯å¦æ­£ç¡®</span>';
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error('è¿æ¥å¤±è´¥:', error);
                    document.getElementById('roomInfo').innerHTML += 
                        '<br><span style="color:#ff6b6b">è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ID</span>';
                }
            }
            
            // è®¾ç½®è¿æ¥
            setupConnection() {
                this.conn.on('open', () => {
                    console.log('Peerè¿æ¥å·²å»ºç«‹ï¼');
                    document.getElementById('connectionStatus').innerHTML = 
                        `<span style="color:#68d391">âœ… å·²è¿æ¥ï¼</span>`;
                    this.startNetworkGame();
                });
                
                this.conn.on('data', (data) => {
                    this.handleNetworkData(data);
                });
                
                this.conn.on('close', () => {
                    console.log('è¿æ¥å·²å…³é—­');
                    this.connected = false;
                    document.getElementById('connectionStatus').innerHTML = 
                        `<span style="color:#ff6b6b">âŒ è¿æ¥æ–­å¼€</span>`;
                });
                
                this.conn.on('error', (err) => {
                    console.error('è¿æ¥é”™è¯¯:', err);
                });
            }
            
            // å‘é€æ•°æ®
            send(data) {
                if (this.conn && this.conn.open) {
                    try {
                        this.conn.send(JSON.stringify(data));
                        return true;
                    } catch (error) {
                        console.error('å‘é€æ•°æ®å¤±è´¥:', error);
                        return false;
                    }
                }
                return false;
            }
            
            // å¤„ç†ç½‘ç»œæ•°æ®
            handleNetworkData(rawData) {
                try {
                    const data = JSON.parse(rawData);
                    
                    if (data.type === 'tank') {
                        // åŒæ­¥å¯¹æ–¹å¦å…‹
                        const remoteTank = this.isHost ? tank2 : tank1;
                        if (remoteTank && remoteTank.isAlive) {
                            remoteTank.x = data.x;
                            remoteTank.y = data.y;
                            remoteTank.angle = data.angle;
                            remoteTank.isMoving = data.isMoving || false;
                        }
                    } else if (data.type === 'bullet') {
                        // åŒæ­¥å­å¼¹ï¼ˆåªå¤„ç†å¯¹æ–¹çš„å­å¼¹ï¼‰
                        if ((this.isHost && data.tankId === 2) || (!this.isHost && data.tankId === 1)) {
                            // æ£€æŸ¥å­å¼¹æ˜¯å¦å·²å­˜åœ¨ï¼ˆé˜²æ­¢é‡å¤ï¼‰
                            const bulletExists = bullets.some(b => 
                                Math.abs(b.x - data.x) < 5 && 
                                Math.abs(b.y - data.y) < 5 && 
                                Math.abs(b.angle - data.angle) < 0.1
                            );
                            
                            if (!bulletExists) {
                                bullets.push(new Bullet(data.x, data.y, data.angle, data.color, data.tankId));
                            }
                        }
                    } else if (data.type === 'score') {
                        // åŒæ­¥åˆ†æ•°
                        score1 = data.score1;
                        score2 = data.score2;
                        score1El.textContent = score1;
                        score2El.textContent = score2;
                    } else if (data.type === 'hit') {
                        // åŒæ­¥å‡»ä¸­äº‹ä»¶
                        if (data.player === 1 && tank1.isAlive) {
                            tank1.hit();
                        } else if (data.player === 2 && tank2.isAlive) {
                            tank2.hit();
                        }
                    } else if (data.type === 'walls') {
                        // åŒæ­¥åœ°å›¾ï¼ˆä¸»æœºå‘é€ç»™å®¢æˆ·ç«¯ï¼‰
                        if (!this.isHost) {
                            walls = data.walls.map(w => ({x: w.x, y: w.y}));
                            console.log('å®¢æˆ·ç«¯æ”¶åˆ°åœ°å›¾æ•°æ®ï¼Œå¢™å£æ•°é‡:', walls.length);
                        }
                    } else if (data.type === 'sync_request') {
                        // å®¢æˆ·ç«¯è¯·æ±‚åŒæ­¥
                        if (this.isHost) {
                            // å‘é€å®Œæ•´çŠ¶æ€
                            this.sendFullState();
                        }
                    } else if (data.type === 'reset_round') {
                        // æ¥æ”¶é‡ç½®å›åˆæŒ‡ä»¤
                        if (!this.isHost) {
                            resetRound();
                        }
                    } else if (data.type === 'reset_game') {
                        // æ¥æ”¶é‡ç½®æ¸¸æˆæŒ‡ä»¤
                        if (!this.isHost) {
                            resetGame();
                        }
                    } else if (data.type === 'request_map') {
                        // å®¢æˆ·ç«¯è¯·æ±‚åœ°å›¾
                        if (this.isHost) {
                            console.log('æ”¶åˆ°å®¢æˆ·ç«¯åœ°å›¾è¯·æ±‚ï¼Œå‘é€å½“å‰åœ°å›¾');
                            this.send({
                                type: 'walls',
                                walls: walls,
                                timestamp: Date.now()
                            });
                        }
                    }
                } catch(e) {
                    console.error('æ•°æ®è§£æé”™è¯¯:', e, rawData);
                }
            }
            
            // å‘é€å®Œæ•´çŠ¶æ€ï¼ˆä¸»æœºç”¨ï¼‰
            sendFullState() {
                if (!this.isHost || !this.connected) return;
                
                this.send({
                    type: 'score',
                    score1: score1,
                    score2: score2,
                    timestamp: Date.now()
                });
                
                this.send({
                    type: 'walls',
                    walls: walls,
                    timestamp: Date.now()
                });
                
                // å‘é€å¦å…‹çŠ¶æ€
                this.send({
                    type: 'tank',
                    x: tank1.x,
                    y: tank1.y,
                    angle: tank1.angle,
                    tankId: 1,
                    timestamp: Date.now()
                });
                
                this.send({
                    type: 'tank',
                    x: tank2.x,
                    y: tank2.y,
                    angle: tank2.angle,
                    tankId: 2,
                    timestamp: Date.now()
                });
            }
            
            // å¼€å§‹ç½‘ç»œæ¸¸æˆ
            startNetworkGame() {
                // åˆ†é…æ§åˆ¶æƒ
                if (this.isHost) {
                    // ä¸»æœºæ§åˆ¶çº¢å¦å…‹ï¼ŒåŒæ­¥è“å¦å…‹
                    tank1.isLocal = true;
                    tank2.isLocal = false;
                    console.log('ä½ æ˜¯ä¸»æœºï¼Œæ§åˆ¶çº¢å¦å…‹');
                    
                    // å‘é€åˆå§‹åœ°å›¾ç»™å®¢æˆ·ç«¯
                    setTimeout(() => {
                        console.log('ä¸»æœºå‘é€åˆå§‹åœ°å›¾ç»™å®¢æˆ·ç«¯');
                        this.send({
                            type: 'walls',
                            walls: walls,
                            timestamp: Date.now()
                        });
                    }, 500);
                } else {
                    // å®¢æˆ·ç«¯æ§åˆ¶è“å¦å…‹ï¼ŒåŒæ­¥çº¢å¦å…‹
                    tank1.isLocal = false;
                    tank2.isLocal = true;
                    console.log('ä½ æ˜¯å®¢æˆ·ç«¯ï¼Œæ§åˆ¶è“å¦å…‹');
                    
                    // è¯·æ±‚å®Œæ•´çŠ¶æ€åŒæ­¥
                    setTimeout(() => {
                        console.log('å®¢æˆ·ç«¯è¯·æ±‚å®Œæ•´çŠ¶æ€åŒæ­¥');
                        this.send({
                            type: 'sync_request',
                            timestamp: Date.now()
                        });
                    }, 500);
                }
                
                // éšè—è”æœºé¢æ¿
                document.getElementById('networkPanel').style.display = 'none';
                
                // å¼€å§‹ç½‘ç»œåŒæ­¥
                this.startNetworkSync();
            }
            
            // å¼€å§‹ç½‘ç»œåŒæ­¥
            startNetworkSync() {
                // æ¯100msåŒæ­¥ä¸€æ¬¡çŠ¶æ€
                const syncInterval = setInterval(() => {
                    if (!this.connected) {
                        clearInterval(syncInterval);
                        return;
                    }
                    
                    const now = Date.now();
                    // é™åˆ¶åŒæ­¥é¢‘ç‡
                    if (now - this.lastSyncTime < 100) return;
                    this.lastSyncTime = now;
                    
                    // åŒæ­¥è‡ªå·±çš„å¦å…‹
                    const myTank = this.isHost ? tank1 : tank2;
                    const tankId = this.isHost ? 1 : 2;
                    
                    if (myTank && myTank.isAlive) {
                        this.send({
                            type: 'tank',
                            x: myTank.x,
                            y: myTank.y,
                            angle: myTank.angle,
                            tankId: tankId,
                            isMoving: myTank.isMoving,
                            timestamp: now
                        });
                    }
                    
                    // ä¸»æœºåŒæ­¥åˆ†æ•°
                    if (this.isHost) {
                        this.send({
                            type: 'score',
                            score1: score1,
                            score2: score2,
                            timestamp: now
                        });
                    }
                    
                }, 100);
            }
            
            // æ›´æ–°UI
            updateUI() {
                const info = document.getElementById('roomInfo');
                if (this.isHost) {
                    info.innerHTML = `ä½ æ˜¯<span style="color:#ff7e5f">ä¸»æœº</span>ï¼ˆæ§åˆ¶çº¢å¦å…‹ï¼‰`;
                } else {
                    info.innerHTML = `ä½ æ˜¯<span style="color:#4ECDC4">å®¢æˆ·ç«¯</span>ï¼ˆæ§åˆ¶è“å¦å…‹ï¼‰`;
                }
            }
        }
        
        // åˆ›å»ºå…¨å±€ç½‘ç»œå®ä¾‹
        const network = new SimpleNetwork();
        // ============== ç½‘ç»œæ¨¡å—ç»“æŸ ==============

        // ============== æ¸¸æˆæ ¸å¿ƒä»£ç å¼€å§‹ ==============
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const score1El = document.getElementById('score1');
        const score2El = document.getElementById('score2');
        const bulletCount1El = document.getElementById('bulletCount1');
        const bulletCount2El = document.getElementById('bulletCount2');
        const restartBtn = document.getElementById('restartBtn');
        const newMapBtn = document.getElementById('newMapBtn');
        const soundBtn = document.getElementById('soundBtn');

        // æ¸¸æˆçŠ¶æ€
        let score1 = 0, score2 = 0;
        let gameOver = false;
        let roundPaused = false; // å›åˆæš‚åœï¼ˆç”¨äºæ­»äº¡æš‚åœï¼‰
        let deathPauseTimer = 0; // æ­»äº¡æš‚åœè®¡æ—¶å™¨
        let deathPauseDuration = 90; // æ­»äº¡æš‚åœæ—¶é•¿ï¼ˆå¸§æ•°ï¼Œçº¦1.5ç§’ï¼‰
        let waitingForSpace = false; // ç­‰å¾…ç©ºæ ¼é”®çŠ¶æ€
        let deathMessage = ''; // æ­»äº¡æç¤ºä¿¡æ¯
        let walls = [];
        const TILE_SIZE = 40;
        const MAP_WIDTH = Math.floor(canvas.width / TILE_SIZE);
        const MAP_HEIGHT = Math.floor(canvas.height / TILE_SIZE);

        // å­å¼¹ç®¡ç†
        let bullets = [];
        const MAX_BULLETS_PER_TANK = 30; // æ¯æ–¹æœ€å¤šå­å¼¹æ•°
        let tank1Bullets = []; // çº¢æ–¹å­å¼¹åˆ—è¡¨ï¼ˆå­˜å‚¨å­å¼¹IDï¼‰
        let tank2Bullets = []; // è“æ–¹å­å¼¹åˆ—è¡¨ï¼ˆå­˜å‚¨å­å¼¹IDï¼‰
        let bulletIdCounter = 0; // å­å¼¹IDè®¡æ•°å™¨

        // ============== é«˜çº§éŸ³æ•ˆç³»ç»Ÿ ==============
        let soundEnabled = true;
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundGainNode;

        // åˆå§‹åŒ–èƒŒæ™¯éŸ³
        function initBackgroundSound() {
            if (!soundEnabled) return;
            backgroundGainNode = audioContext.createGain();
            backgroundGainNode.gain.setValueAtTime(0.03, audioContext.currentTime);
            backgroundGainNode.connect(audioContext.destination);
            const oscillator = audioContext.createOscillator();
            oscillator.connect(backgroundGainNode);
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(110, audioContext.currentTime);
            oscillator.start();
            return oscillator;
        }
        let bgSound = initBackgroundSound();

        function stopBackgroundSound() {
            if (bgSound) {
                bgSound.stop();
                bgSound = null;
            }
        }

        function playSound(freq, duration, type='sine', vol=0.2, freqVary=0) {
            if (!soundEnabled || !audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                const baseFreq = freq + (Math.random() * 2 - 1) * freqVary;
                oscillator.frequency.setValueAtTime(baseFreq, audioContext.currentTime);
                oscillator.type = type;
                gainNode.gain.setValueAtTime(vol, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch(e) {}
        }

        // ä¸°å¯Œå¤šæ ·çš„éŸ³æ•ˆå‡½æ•°
        function playShootSound() {
            const variants = [
                () => playSound(600 + Math.random()*300, 0.08, 'square', 0.18, 50),
                () => playSound(800 + Math.random()*200, 0.1, 'sawtooth', 0.16, 40),
                () => playSound(500, 0.12, 'triangle', 0.15, 30)
            ];
            variants[Math.floor(Math.random() * variants.length)]();
        }

        // å­å¼¹åå¼¹éŸ³æ•ˆï¼š3ç§ç›¸è¿‘é¢‘ç‡çš„éšæœºéŸ³æ•ˆ
        function playHitWallSound() {
            const frequencies = [250, 300, 350];
            const freq = frequencies[Math.floor(Math.random() * frequencies.length)];
            playSound(freq, 0.08, 'sawtooth', 0.08, 10);
        }

        function playHitTankSound() {
            playSound(80, 0.4, 'sine', 0.3, 5);
            setTimeout(() => playSound(60, 0.5, 'sine', 0.25, 3), 50);
        }

        function playExplosionSound() {
            for(let i=0; i<5; i++) {
                setTimeout(() => {
                    playSound(40 + i*15, 0.3, 'sawtooth', 0.2, 10);
                }, i * 60);
            }
        }

        function playEngineSound(isMoving) {
            if(!isMoving || !soundEnabled) return;
            playSound(50, 0.2, 'sine', 0.05, 2);
        }

        function playWinSound() {
            const melody = [523.25, 659.25, 783.99, 1046.50];
            melody.forEach((freq, i) => {
                setTimeout(() => playSound(freq, 0.4, 'sine', 0.3), i * 220);
            });
        }

        // ============== çˆ†ç‚¸ç²’å­ç³»ç»Ÿ ==============
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = Math.random() * 6 + 2;
                this.speedX = Math.random() * 6 - 3;
                this.speedY = Math.random() * 6 - 3;
                this.life = 1.0;
                this.decay = Math.random() * 0.05 + 0.02;
            }
            update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.life -= this.decay;
                return this.life > 0;
            }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        let particles = [];

        function createExplosion(x, y, color) {
            playExplosionSound();
            for(let i=0; i<25; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        // ============== æ¸¸æˆå¯¹è±¡ ==============
        function generateWalls() {
            walls = [];
            for(let y=1; y<MAP_HEIGHT-1; y++) {
                for(let x=1; x<MAP_WIDTH-1; x++) {
                    const nearCenter = (x > MAP_WIDTH/2-3 && x < MAP_WIDTH/2+2 &&
                                      y > MAP_HEIGHT/2-2 && y < MAP_HEIGHT/2+2);
                    const isSpawn = (x<3 && y<3) || (x>MAP_WIDTH-4 && y>MAP_HEIGHT-4);
                    if(Math.random() < 0.22 && !nearCenter && !isSpawn) {
                        walls.push({x: x*TILE_SIZE, y: y*TILE_SIZE});
                    }
                }
            }
            if(walls.length < 10) {
                for(let i=0; i<10; i++) {
                    walls.push({
                        x: Math.floor(Math.random()*(MAP_WIDTH-4)+2)*TILE_SIZE,
                        y: Math.floor(Math.random()*(MAP_HEIGHT-4)+2)*TILE_SIZE
                    });
                }
            }
            
            // å¦‚æœæ˜¯è”æœºæ¨¡å¼ä¸”æ˜¯ä¸»æœºï¼Œå‘é€åœ°å›¾ç»™å®¢æˆ·ç«¯
            if (network && network.connected && network.isHost) {
                console.log('ä¸»æœºç”Ÿæˆæ–°åœ°å›¾ï¼Œå‘é€ç»™å®¢æˆ·ç«¯ï¼Œå¢™å£æ•°é‡:', walls.length);
                network.send({
                    type: 'walls',
                    walls: walls,
                    timestamp: Date.now()
                });
            }
        }

        class Tank {
            constructor(x, y, color, controls) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.width = 24;
                this.height = 24;
                this.angle = 0;
                this.speed = 2.2;
                this.controls = controls;
                this.cooldown = 0;
                this.cooldownMax = 20;
                this.lastMove = { x:0, y:0 };
                this.isMoving = false;
                this.moveSoundTimer = 0;
                this.isAlive = true;
                this.isVisible = true;
                this.isLocal = true; // é»˜è®¤æœ¬åœ°æ§åˆ¶ï¼Œç½‘ç»œè¿æ¥åä¼šä¿®æ”¹
            }
            update(keys) {
                // å¦‚æœæ˜¯ç½‘ç»œæ¨¡å¼ä¸”ä¸æ˜¯æœ¬åœ°æ§åˆ¶çš„å¦å…‹ï¼Œåˆ™ä¸å“åº”é”®ç›˜
                if (network.connected && !this.isLocal) {
                    // ä½†å¦å…‹ä»ç„¶ä¼šè¢«ç½‘ç»œæ•°æ®æ›´æ–°ä½ç½®
                    return;
                }
                
                // å¦‚æœæ¸¸æˆæš‚åœæˆ–æ¸¸æˆç»“æŸï¼Œä¸æ¥å—è¾“å…¥
                if(roundPaused || gameOver) return;
                
                // å¦‚æœå¦å…‹æ­»äº¡ï¼Œä¸æ¥å—è¾“å…¥
                if(!this.isAlive) return;

                let moveX=0, moveY=0;
                this.isMoving = false;

                if(keys[this.controls.up]) { moveY -= 1; this.lastMove = {x:0,y:-1}; this.isMoving=true; }
                if(keys[this.controls.down]) { moveY += 1; this.lastMove = {x:0,y:1}; this.isMoving=true; }
                if(keys[this.controls.left]) { moveX -= 1; this.lastMove = {x:-1,y:0}; this.isMoving=true; }
                if(keys[this.controls.right]) { moveX += 1; this.lastMove = {x:1,y:0}; this.isMoving=true; }

                if(this.isMoving) {
                    this.angle = Math.atan2(this.lastMove.y, this.lastMove.x);
                    this.moveSoundTimer++;
                    if(this.moveSoundTimer > 10) {
                        playEngineSound(true);
                        this.moveSoundTimer = 0;
                    }
                }

                // ç‹¬ç«‹å¤„ç†æ¯ä¸ªè½´å‘çš„ç§»åŠ¨
                let newX = this.x;
                let newY = this.y;

                if(moveX !== 0) {
                    newX = this.x + moveX * this.speed;
                    if(newX < -this.width/2) newX = canvas.width - this.width/2;
                    if(newX > canvas.width - this.width/2) newX = -this.width/2;
                    let canMoveX = true;
                    for(let wall of walls) {
                        if(this.collidesWith(wall, newX, this.y)) {
                            canMoveX = false;
                            break;
                        }
                    }
                    if(canMoveX) {
                        this.x = newX;
                    }
                }

                if(moveY !== 0) {
                    newY = this.y + moveY * this.speed;
                    if(newY < -this.height/2) newY = canvas.height - this.height/2;
                    if(newY > canvas.height - this.height/2) newY = -this.height/2;
                    let canMoveY = true;
                    for(let wall of walls) {
                        if(this.collidesWith(wall, this.x, newY)) {
                            canMoveY = false;
                            break;
                        }
                    }
                    if(canMoveY) {
                        this.y = newY;
                    }
                }

                if(this.cooldown > 0) this.cooldown--;
                if(keys[this.controls.fire] && this.cooldown === 0 && this.isAlive) {
                    const bx = this.x + Math.cos(this.angle)*20;
                    const by = this.y + Math.sin(this.angle)*20;
                    
                    // æ£€æŸ¥ç‚®å£æ˜¯å¦æ·±å…¥å¢™å£
                    let bulletAngle = this.angle;
                    let bulletX = bx;
                    let bulletY = by;
                    
                    // ä¿®å¤ï¼šæ£€æµ‹ç‚®å£æ˜¯å¦åœ¨å¢™å£å†…
                    for(let wall of walls) {
                        if(this.bulletSpawnInWall(bulletX, bulletY, wall)) {
                            // ç‚®å£åœ¨å¢™å£å†…ï¼Œè®¡ç®—åå¼¹æ–¹å‘
                            const tankToWallX = wall.x + TILE_SIZE/2 - this.x;
                            const tankToWallY = wall.y + TILE_SIZE/2 - this.y;
                            
                            // åˆ¤æ–­å¢™å£ç›¸å¯¹äºå¦å…‹çš„æ–¹å‘
                            if(Math.abs(tankToWallX) > Math.abs(tankToWallY)) {
                                // æ°´å¹³æ–¹å‘åå¼¹
                                bulletAngle = Math.PI - bulletAngle;
                            } else {
                                // å‚ç›´æ–¹å‘åå¼¹
                                bulletAngle = -bulletAngle;
                            }
                            
                            // è°ƒæ•´å­å¼¹å‡ºç”Ÿç‚¹åˆ°å¢™å£è¾¹ç¼˜
                            bulletX = this.x + Math.cos(bulletAngle)*25;
                            bulletY = this.y + Math.sin(bulletAngle)*25;
                            break;
                        }
                    }
                    
                    // å‘å°„å­å¼¹ï¼ˆä¼šå¤„ç†å­å¼¹æ•°é‡é™åˆ¶ï¼‰
                    this.shootBullet(bulletX, bulletY, bulletAngle);
                    this.cooldown = this.cooldownMax;
                    playShootSound();
                }
            }
            
            // å‘å°„å­å¼¹ï¼ˆå¤„ç†å­å¼¹æ•°é‡é™åˆ¶ï¼‰
            shootBullet(x, y, angle) {
                // æ£€æŸ¥å­å¼¹æ•°é‡é™åˆ¶
                const tankBullets = this === tank1 ? tank1Bullets : tank2Bullets;
                
                if(tankBullets.length >= MAX_BULLETS_PER_TANK) {
                    // ç§»é™¤æœ€æ—©å‘å°„çš„å­å¼¹
                    const oldestBulletId = tankBullets[0];
                    for(let i = bullets.length - 1; i >= 0; i--) {
                        if(bullets[i].id === oldestBulletId) {
                            bullets.splice(i, 1);
                            break;
                        }
                    }
                    tankBullets.shift(); // ä»å¦å…‹å­å¼¹åˆ—è¡¨ä¸­ç§»é™¤
                }
                
                // åˆ›å»ºæ–°å­å¼¹
                const tankId = this === tank1 ? 1 : 2;
                const newBullet = new Bullet(x, y, angle, this.color, tankId);
                bullets.push(newBullet);
                tankBullets.push(newBullet.id);
                
                // ç½‘ç»œåŒæ­¥å­å¼¹
                if (network && network.connected) {
                    network.send({
                        type: 'bullet',
                        x: x,
                        y: y,
                        angle: angle,
                        color: this.color,
                        tankId: tankId,
                        timestamp: Date.now()
                    });
                }
                
                // æ›´æ–°å­å¼¹æ•°é‡æ˜¾ç¤º
                updateBulletCount();
            }
            
            // æ£€æŸ¥å­å¼¹å‡ºç”Ÿç‚¹æ˜¯å¦åœ¨å¢™å£å†…
            bulletSpawnInWall(bx, by, wall) {
                return bx > wall.x && bx < wall.x + TILE_SIZE &&
                       by > wall.y && by < wall.y + TILE_SIZE;
            }
            
            // å¤„ç†å¦å…‹è¢«å‡»ä¸­
            hit() {
                if (!this.isAlive) return;
                this.isAlive = false;
                this.isVisible = false;
                createExplosion(this.x, this.y, this.color);
                playHitTankSound();
                
                // ç½‘ç»œåŒæ­¥å‡»ä¸­äº‹ä»¶
                if (network && network.connected) {
                    const playerId = this === tank1 ? 1 : 2;
                    network.send({
                        type: 'hit',
                        player: playerId,
                        timestamp: Date.now()
                    });
                }
                
                // è®¾ç½®æ­»äº¡æš‚åœ
                startDeathPause(this === tank1 ? 'ç©å®¶1ï¼ˆçº¢ï¼‰' : 'ç©å®¶2ï¼ˆè“ï¼‰');
            }
            // é‡ç½®å¦å…‹çŠ¶æ€
            reset(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.isAlive = true;
                this.isVisible = true;
                this.cooldown = 0;
                // é‡ç½®æ—¶ä¿æŒæœ¬åœ°æ§åˆ¶çŠ¶æ€
                if (network.connected) {
                    this.isLocal = (network.isHost && this === tank1) || (!network.isHost && this === tank2);
                } else {
                    this.isLocal = true;
                }
            }
            collidesWith(wall, x=this.x, y=this.y) {
                return !(x+this.width/2 < wall.x ||
                         x-this.width/2 > wall.x+TILE_SIZE ||
                         y+this.height/2 < wall.y ||
                         y-this.height/2 > wall.y+TILE_SIZE);
            }
            draw() {
                if (!this.isVisible) return;
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.fillStyle = this.color;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.fillStyle = '#222';
                ctx.fillRect(-this.width/2-2, -this.height/2-2, this.width+4, 4);
                ctx.fillRect(-this.width/2-2, this.height/2-2, this.width+4, 4);
                ctx.fillStyle = '#111';
                ctx.fillRect(0, -3, 22, 6);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this===tank1?'1':'2', 0, 0);
                ctx.restore();
            }
        }

        class Bullet {
            constructor(x, y, angle, color, tankId) {
                this.id = ++bulletIdCounter; // å”¯ä¸€ID
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = 7.5;
                this.color = color;
                this.radius = 3.5;
                this.bounces = 0;
                this.maxBounces = 50;
                this.tankId = tankId; // 1=çº¢æ–¹ï¼Œ2=è“æ–¹
            }
            update() {
                // å¦‚æœæ¸¸æˆæš‚åœï¼Œå­å¼¹ä¸æ›´æ–°
                if(roundPaused) return true;
                
                this.x += Math.cos(this.angle)*this.speed;
                this.y += Math.sin(this.angle)*this.speed;
                if(this.x < -10) this.x = canvas.width+10;
                if(this.x > canvas.width+10) this.x = -10;
                if(this.y < -10) this.y = canvas.height+10;
                if(this.y > canvas.height+10) this.y = -10;
                for(let wall of walls) {
                    if(this.collidesWith(wall)) {
                        const bulletLeft = this.x - this.radius;
                        const bulletRight = this.x + this.radius;
                        const bulletTop = this.y - this.radius;
                        const bulletBottom = this.y + this.radius;
                        const wallLeft = wall.x;
                        const wallRight = wall.x + TILE_SIZE;
                        const wallTop = wall.y;
                        const wallBottom = wall.y + TILE_SIZE;
                        const fromLeft = Math.abs(bulletRight - wallLeft);
                        const fromRight = Math.abs(bulletLeft - wallRight);
                        const fromTop = Math.abs(bulletBottom - wallTop);
                        const fromBottom = Math.abs(bulletTop - wallBottom);
                        const min = Math.min(fromLeft, fromRight, fromTop, fromBottom);
                        if(min === fromLeft || min === fromRight) this.angle = Math.PI - this.angle;
                        else this.angle = -this.angle;
                        this.bounces++;
                        this.x += Math.cos(this.angle)*5;
                        this.y += Math.sin(this.angle)*5;
                        playHitWallSound();
                        break;
                    }
                }
                if(this.bounces > this.maxBounces) {
                    // å­å¼¹æ¶ˆå¤±æ—¶ä»å¦å…‹å­å¼¹åˆ—è¡¨ä¸­ç§»é™¤
                    removeBulletFromTankList(this.id, this.tankId);
                    return false;
                }

                // å­å¼¹å‘½ä¸­æ£€æµ‹
                if(this.hits(tank1) && this.color !== '#FF6B6B' && tank1.isAlive) {
                    tank1.hit();
                    score2++;
                    score2El.textContent = score2;
                    checkGameEnd();
                    // å­å¼¹å‘½ä¸­æ—¶ä»å¦å…‹å­å¼¹åˆ—è¡¨ä¸­ç§»é™¤
                    removeBulletFromTankList(this.id, this.tankId);
                    return false;
                }
                if(this.hits(tank2) && this.color !== '#4ECDC4' && tank2.isAlive) {
                    tank2.hit();
                    score1++;
                    score1El.textContent = score1;
                    checkGameEnd();
                    // å­å¼¹å‘½ä¸­æ—¶ä»å¦å…‹å­å¼¹åˆ—è¡¨ä¸­ç§»é™¤
                    removeBulletFromTankList(this.id, this.tankId);
                    return false;
                }
                return true;
            }
            collidesWith(wall) {
                return this.x+this.radius > wall.x &&
                       this.x-this.radius < wall.x+TILE_SIZE &&
                       this.y+this.radius > wall.y &&
                       this.y-this.radius < wall.y+TILE_SIZE;
            }
            hits(tank) {
                const dx = this.x - tank.x;
                const dy = this.y - tank.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                return distance < this.radius + tank.width/2;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // ä»å¦å…‹å­å¼¹åˆ—è¡¨ä¸­ç§»é™¤å­å¼¹
        function removeBulletFromTankList(bulletId, tankId) {
            if(tankId === 1) {
                const index = tank1Bullets.indexOf(bulletId);
                if(index !== -1) tank1Bullets.splice(index, 1);
            } else if(tankId === 2) {
                const index = tank2Bullets.indexOf(bulletId);
                if(index !== -1) tank2Bullets.splice(index, 1);
            }
            updateBulletCount();
        }
        
        // æ›´æ–°å­å¼¹æ•°é‡æ˜¾ç¤º
        function updateBulletCount() {
            bulletCount1El.textContent = tank1Bullets.length;
            bulletCount2El.textContent = tank2Bullets.length;
        }

        let tank1, tank2;
        function initGame() {
            // åˆå§‹åŒ–ç½‘ç»œ
            network.init();
            
            tank1 = new Tank(100, 100, '#FF6B6B', {
                up:'KeyW', down:'KeyS', left:'KeyA', right:'KeyD', fire:'KeyF'
            });
            tank2 = new Tank(canvas.width-100, canvas.height-100, '#4ECDC4', {
                up:'ArrowUp', down:'ArrowDown', left:'ArrowLeft', right:'ArrowRight', fire:'KeyM'
            });
            bullets = [];
            particles = [];
            tank1Bullets = [];
            tank2Bullets = [];
            bulletIdCounter = 0;
            gameOver = false;
            roundPaused = false;
            waitingForSpace = false;
            deathPauseTimer = 0;
            updateBulletCount();
            
            // ç”Ÿæˆåœ°å›¾ï¼šæœ¬åœ°æ¸¸æˆåŒæ–¹éƒ½ç”Ÿæˆï¼Œè”æœºæ¸¸æˆåªæœ‰ä¸»æœºç”Ÿæˆ
            if (!network.connected || network.isHost) {
                generateWalls();
            } else {
                // å®¢æˆ·ç«¯ç­‰å¾…ä¸»æœºå‘é€åœ°å›¾
                walls = [];
                console.log('å®¢æˆ·ç«¯åˆå§‹åŒ–ï¼Œç­‰å¾…ä¸»æœºå‘é€åœ°å›¾');
            }
            
            // é‡ç½®å¦å…‹æ§åˆ¶æƒï¼ˆå¦‚æœæ˜¯ç½‘ç»œæ¸¸æˆï¼Œä¼šåœ¨è¿æ¥åé‡æ–°è®¾ç½®ï¼‰
            if (network.connected) {
                tank1.isLocal = network.isHost;
                tank2.isLocal = !network.isHost;
            }
        }

        // ============== æ™ºèƒ½é‡ç½®ç³»ç»Ÿ ==============
        
        // å¼€å§‹æ­»äº¡æš‚åœ
        function startDeathPause(deathPlayer) {
            roundPaused = true;
            deathPauseTimer = deathPauseDuration;
            deathMessage = `${deathPlayer} è¢«å‡»ä¸­ï¼`;
        }
        
        // æ›´æ–°æ­»äº¡æš‚åœ
        function updateDeathPause() {
            if (deathPauseTimer > 0) {
                deathPauseTimer--;
                if (deathPauseTimer <= 0) {
                    // æš‚åœç»“æŸï¼Œè¿›å…¥ç­‰å¾…ç©ºæ ¼çŠ¶æ€
                    waitingForSpace = true;
                    deathMessage = "æŒ‰ç©ºæ ¼é”®é‡æ–°å¼€å§‹å½“å‰å›åˆ";
                }
            }
        }
        
        // é‡ç½®å½“å‰å›åˆï¼ˆä¸é‡ç½®åˆ†æ•°ï¼‰
        function resetRound() {
            // é‡ç½®å¦å…‹ä½ç½®å’ŒçŠ¶æ€
            tank1.reset(100, 100, 0);
            tank2.reset(canvas.width - 100, canvas.height - 100, Math.PI);
            
            // æ¸…ç©ºå­å¼¹å’Œç²’å­
            bullets = [];
            particles = [];
            tank1Bullets = [];
            tank2Bullets = [];
            bulletIdCounter = 0;
            
            // ç”Ÿæˆæ–°åœ°å›¾ï¼ˆåªæœ‰ä¸»æœºç”Ÿæˆåœ°å›¾ï¼‰
            if (!network.connected || network.isHost) {
                generateWalls();
            } else {
                // å®¢æˆ·ç«¯æ¸…ç©ºå¢™å£ï¼Œè¯·æ±‚æ–°åœ°å›¾
                walls = [];
                console.log('å®¢æˆ·ç«¯é‡ç½®å›åˆï¼Œè¯·æ±‚æ–°åœ°å›¾');
                // ç«‹å³å‘ä¸»æœºè¯·æ±‚åœ°å›¾
                if (network && network.connected && !network.isHost) {
                    network.send({
                        type: 'request_map',
                        timestamp: Date.now()
                    });
                }
            }
            
            // é‡ç½®æš‚åœçŠ¶æ€
            roundPaused = false;
            waitingForSpace = false;
            deathPauseTimer = 0;
            updateBulletCount();
        }
        
        // é‡ç½®æ•´ä¸ªæ¸¸æˆï¼ˆé‡ç½®åˆ†æ•°ï¼‰
        function resetGame() {
            score1 = 0;
            score2 = 0;
            score1El.textContent = '0';
            score2El.textContent = '0';
            initGame();
            
            // ç½‘ç»œåŒæ­¥åˆ†æ•°
            if (network && network.connected) {
                network.send({
                    type: 'score',
                    score1: 0,
                    score2: 0,
                    timestamp: Date.now()
                });
            }
        }
        
        // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
        function checkGameEnd() {
            if (score1 >= 5 || score2 >= 5) {
                gameOver = true;
                playWinSound();
            }
        }
        
        // å¤„ç†ç©ºæ ¼é”®æŒ‰ä¸‹ - ä¿®å¤ï¼šåªæœ‰ä¸»æœºèƒ½é‡ç½®
        function handleSpaceKey() {
            // å¦‚æœæ˜¯è”æœºæ¨¡å¼ä¸”ä¸æ˜¯ä¸»æœºï¼Œåˆ™å®¢æˆ·ç«¯ä¸èƒ½é‡ç½®
            if (network.connected && !network.isHost) {
                return; // å®¢æˆ·ç«¯ä¸å“åº”ç©ºæ ¼é”®
            }
            
            // ç©ºæ ¼é”®æœ€é«˜ä¼˜å…ˆçº§ï¼Œç«‹å³å¤„ç†
            if (gameOver) {
                // æ¸¸æˆç»“æŸçŠ¶æ€ï¼šé‡ç½®æ•´ä¸ªæ¸¸æˆ
                resetGame();
                
                // å¦‚æœæ˜¯ä¸»æœºï¼Œé€šçŸ¥å®¢æˆ·ç«¯é‡ç½®æ¸¸æˆ
                if (network && network.connected && network.isHost) {
                    network.send({
                        type: 'reset_game',
                        timestamp: Date.now()
                    });
                }
            } else if (waitingForSpace || roundPaused) {
                // æ­»äº¡æš‚åœçŠ¶æ€ï¼šé‡ç½®å½“å‰å›åˆ
                resetRound();
                
                // å¦‚æœæ˜¯ä¸»æœºï¼Œé€šçŸ¥å®¢æˆ·ç«¯é‡ç½®å›åˆ
                if (network && network.connected && network.isHost) {
                    network.send({
                        type: 'reset_round',
                        timestamp: Date.now()
                    });
                }
            } else {
                // æ¸¸æˆè¿›è¡Œä¸­ï¼šé‡ç½®å½“å‰å›åˆ
                resetRound();
                
                // å¦‚æœæ˜¯ä¸»æœºï¼Œé€šçŸ¥å®¢æˆ·ç«¯é‡ç½®å›åˆ
                if (network && network.connected && network.isHost) {
                    network.send({
                        type: 'reset_round',
                        timestamp: Date.now()
                    });
                }
            }
        }

        // ============== è¾“å…¥æ§åˆ¶ ==============
        const keys = {};
        const gameKeyCodes = [
            'KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyF',
            'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'KeyM',
            'KeyN', 'Space', 'KeyR'
        ];
        
        window.addEventListener('keydown', e => {
            if (gameKeyCodes.includes(e.code)) {
                e.preventDefault();
            }
            
            keys[e.code] = true;
            
            // ç©ºæ ¼é”®å¤„ç†ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
            if(e.code === 'Space') {
                handleSpaceKey();
            }
            
            if(e.code === 'KeyN') {
                soundEnabled = !soundEnabled;
                soundBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆå¼€å¯ä¸­' : 'ğŸ”‡ éŸ³æ•ˆå·²å…³é—­';
                if(soundEnabled && audioContext.state === 'suspended') audioContext.resume();
                if(soundEnabled && !bgSound) bgSound = initBackgroundSound();
                if(!soundEnabled) stopBackgroundSound();
            }
            if(e.code === 'KeyR') {
                // Ré”®ç”Ÿæˆæ–°åœ°å›¾ï¼Œè”æœºæ¨¡å¼ä¸‹åªæœ‰ä¸»æœºèƒ½ç”Ÿæˆ
                if (network.connected && !network.isHost) {
                    return; // å®¢æˆ·ç«¯ä¸èƒ½ç”Ÿæˆæ–°åœ°å›¾
                }
                
                generateWalls();
                bullets = [];
                tank1Bullets = [];
                tank2Bullets = [];
                updateBulletCount();
            }
        });
        
        window.addEventListener('keyup', e => { 
            if (gameKeyCodes.includes(e.code)) {
                e.preventDefault();
            }
            keys[e.code] = false; 
        });

        // æŒ‰é’®äº‹ä»¶
        restartBtn.addEventListener('click', () => {
            resetGame();
        });
        newMapBtn.addEventListener('click', () => {
            // è”æœºæ¨¡å¼ä¸‹åªæœ‰ä¸»æœºèƒ½ç”Ÿæˆæ–°åœ°å›¾
            if (network.connected && !network.isHost) {
                alert('åªæœ‰ä¸»æœºå¯ä»¥ç”Ÿæˆæ–°åœ°å›¾ï¼');
                return;
            }
            
            generateWalls();
            bullets = [];
            tank1Bullets = [];
            tank2Bullets = [];
            updateBulletCount();
        });
        soundBtn.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            soundBtn.textContent = soundEnabled ? 'ğŸ”Š éŸ³æ•ˆå¼€å¯ä¸­' : 'ğŸ”‡ éŸ³æ•ˆå·²å…³é—­';
            if(soundEnabled && audioContext.state === 'suspended') audioContext.resume();
            if(soundEnabled && !bgSound) bgSound = initBackgroundSound();
            if(!soundEnabled) stopBackgroundSound();
        });

        // ============== è”æœºé¢æ¿äº‹ä»¶ç›‘å¬ ==============
        document.getElementById('hostBtn').onclick = () => {
            document.getElementById('roomSection').style.display = 'block';
            // ç­‰å¾…IDç”Ÿæˆ
            const waitForId = setInterval(() => {
                if (network.myId) {
                    document.getElementById('roomInfo').innerHTML = 
                        `ä½ çš„æˆ¿é—´ID: <span style="color:#ff7e5f">${network.myId}</span><br>
                         åˆ†äº«è¿™ä¸ªIDç»™ä½ çš„æœ‹å‹ï¼<br>
                         <small style="color:#a0aec0">ï¼ˆå¦‚æœIDæ²¡æ˜¾ç¤ºï¼Œç¨ç­‰å‡ ç§’åˆ·æ–°ï¼‰</small>`;
                    clearInterval(waitForId);
                }
            }, 500);
        };

        document.getElementById('joinBtn').onclick = () => {
            document.getElementById('roomSection').style.display = 'block';
            document.getElementById('roomInfo').innerHTML = 
                'è¾“å…¥ä¸»æœºçš„æˆ¿é—´IDå¹¶ç‚¹å‡»è¿æ¥<br><small style="color:#a0aec0">ï¼ˆæ³¨æ„åŒºåˆ†å¤§å°å†™ï¼‰</small>';
        };

        document.getElementById('connectBtn').onclick = () => {
            const roomId = document.getElementById('roomIdInput').value.trim();
            if (roomId) {
                network.connectTo(roomId);
                document.getElementById('roomInfo').innerHTML += 
                    '<br><span style="color:#4fd1c7">æ­£åœ¨è¿æ¥...</span>';
            } else {
                document.getElementById('roomInfo').innerHTML += 
                    '<br><span style="color:#ff6b6b">è¯·è¾“å…¥æˆ¿é—´ID</span>';
            }
        };
        
        // å›è½¦é”®è¿æ¥
        document.getElementById('roomIdInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('connectBtn').click();
            }
        });
        // ============== è”æœºé¢æ¿äº‹ä»¶ç»“æŸ ==============

        // ============== æ¸²æŸ“å‡½æ•° ==============
        function drawDashedBorder() {
            ctx.strokeStyle = '#00dbde';
            ctx.lineWidth = 3;
            ctx.setLineDash([12, 8]);
            ctx.strokeRect(3, 3, canvas.width-6, canvas.height-6);
            ctx.setLineDash([]);
        }

        function drawWalls() {
            ctx.fillStyle = '#3a506b';
            ctx.strokeStyle = '#1c2d4a';
            ctx.lineWidth = 2;
            for(let wall of walls) {
                ctx.fillRect(wall.x, wall.y, TILE_SIZE, TILE_SIZE);
                ctx.strokeRect(wall.x, wall.y, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = '#4a648f';
                ctx.fillRect(wall.x+4, wall.y+4, TILE_SIZE-8, TILE_SIZE-8);
                ctx.fillStyle = '#3a506b';
            }
        }
        
        // ç»˜åˆ¶æ­»äº¡æš‚åœä¿¡æ¯
        function drawDeathPauseInfo() {
            if (!roundPaused && !waitingForSpace) return;
            
            // åŠé€æ˜èƒŒæ™¯
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // æ­»äº¡ä¿¡æ¯
            ctx.fillStyle = '#ff7e5f';
            ctx.font = 'bold 50px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(deathMessage, canvas.width/2, canvas.height/2 - 50);
            
            // å¦‚æœæ­£åœ¨ç­‰å¾…ç©ºæ ¼é”®
            if (waitingForSpace) {
                ctx.fillStyle = '#4fd1c7';
                ctx.font = '30px Arial';
                // è”æœºæ¨¡å¼ä¸‹æ˜¾ç¤ºæç¤º
                if (network.connected) {
                    if (network.isHost) {
                        ctx.fillText('æŒ‰ç©ºæ ¼é”®ç»§ç»­', canvas.width/2, canvas.height/2 + 30);
                    } else {
                        ctx.fillText('ç­‰å¾…ä¸»æœºç»§ç»­', canvas.width/2, canvas.height/2 + 30);
                    }
                } else {
                    ctx.fillText('æŒ‰ç©ºæ ¼é”®ç»§ç»­', canvas.width/2, canvas.height/2 + 30);
                }
            }
            
            // æ˜¾ç¤ºæš‚åœå€’è®¡æ—¶ï¼ˆå¦‚æœè¿˜åœ¨æš‚åœä¸­ï¼‰
            if (deathPauseTimer > 0) {
                const seconds = (deathPauseTimer / 60).toFixed(1);
                ctx.fillStyle = '#a0aec0';
                ctx.font = '24px Arial';
                ctx.fillText(`æš‚åœ: ${seconds}ç§’`, canvas.width/2, canvas.height/2 + 80);
            }
        }
        
        // ç»˜åˆ¶æ¸¸æˆç»“æŸä¿¡æ¯
        function drawGameOverInfo() {
            if (!gameOver) return;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const winner = score1 >= 5 ? 'ç©å®¶1ï¼ˆçº¢ï¼‰' : 'ç©å®¶2ï¼ˆè“ï¼‰';
            ctx.fillStyle = '#f8c555';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${winner} è·èƒœï¼`, canvas.width/2, canvas.height/2 - 50);
            
            ctx.fillStyle = '#4fd1c7';
            ctx.font = '30px Arial';
            // è”æœºæ¨¡å¼ä¸‹æ˜¾ç¤ºä¸åŒæç¤º
            if (network.connected) {
                if (network.isHost) {
                    ctx.fillText('æŒ‰ç©ºæ ¼é”®é‡æ–°å¼€å§‹æ¸¸æˆ', canvas.width/2, canvas.height/2 + 30);
                } else {
                    ctx.fillText('ç­‰å¾…ä¸»æœºé‡æ–°å¼€å§‹æ¸¸æˆ', canvas.width/2, canvas.height/2 + 30);
                }
            } else {
                ctx.fillText('æŒ‰ç©ºæ ¼é”®é‡æ–°å¼€å§‹æ¸¸æˆ', canvas.width/2, canvas.height/2 + 30);
            }
            
            ctx.fillStyle = '#a0aec0';
            ctx.font = '24px Arial';
            ctx.fillText('ï¼ˆåˆ†æ•°å°†è¢«é‡ç½®ï¼‰', canvas.width/2, canvas.height/2 + 80);
            
            // æ˜¾ç¤ºè”æœºçŠ¶æ€
            if (network.connected) {
                ctx.fillStyle = '#68d391';
                ctx.font = '20px Arial';
                ctx.fillText(network.isHost ? 'ä½ æ˜¯ä¸»æœº' : 'ä½ æ˜¯å®¢æˆ·ç«¯', canvas.width/2, canvas.height/2 + 120);
            }
        }

        // ============== æ¸¸æˆä¸»å¾ªç¯ ==============
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawDashedBorder();
            drawWalls();
            
            // æ›´æ–°æ­»äº¡æš‚åœè®¡æ—¶å™¨
            if (roundPaused && deathPauseTimer > 0) {
                updateDeathPause();
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶ç²’å­ï¼ˆå³ä½¿åœ¨æš‚åœä¸­ä¹Ÿè¦æ›´æ–°ç²’å­ï¼‰
            for(let i=particles.length-1; i>=0; i--) {
                if(!particles[i].update()) {
                    particles.splice(i,1);
                } else {
                    particles[i].draw();
                }
            }
            
            // åªæœ‰åœ¨æ²¡æœ‰æš‚åœæ—¶æ‰æ›´æ–°æ¸¸æˆå¯¹è±¡
            if (!roundPaused && !gameOver) {
                // æ›´æ–°å’Œç»˜åˆ¶å¦å…‹
                tank1.update(keys);
                tank2.update(keys);
                
                // æ›´æ–°å’Œç»˜åˆ¶å­å¼¹
                for(let i=bullets.length-1; i>=0; i--) {
                    if(!bullets[i].update()) {
                        bullets.splice(i,1);
                    } else {
                        bullets[i].draw();
                    }
                }
            }
            
            // ç»˜åˆ¶å¦å…‹ï¼ˆå³ä½¿åœ¨æš‚åœä¸­ä¹Ÿè¦ç»˜åˆ¶ï¼Œå› ä¸ºå¦å…‹å¯èƒ½æ­»äº¡éšè—ï¼‰
            tank1.draw();
            tank2.draw();
            
            // ç»˜åˆ¶æš‚åœä¿¡æ¯æˆ–æ¸¸æˆç»“æŸä¿¡æ¯
            if (gameOver) {
                drawGameOverInfo();
            } else if (roundPaused || waitingForSpace) {
                drawDeathPauseInfo();
            }
            
            // æ˜¾ç¤ºè”æœºçŠ¶æ€
            if (network.connected) {
                ctx.fillStyle = network.isHost ? '#ff7e5f' : '#4ECDC4';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(network.isHost ? 'ä¸»æœº (çº¢æ–¹)' : 'å®¢æˆ·ç«¯ (è“æ–¹)', 20, 30);
                
                // æ˜¾ç¤ºè¿æ¥çŠ¶æ€
                ctx.fillStyle = '#68d391';
                ctx.font = '14px Arial';
                ctx.fillText('å·²è¿æ¥', 20, 50);
                
                // å¦‚æœæ˜¯å®¢æˆ·ç«¯ä¸”æ²¡æœ‰åœ°å›¾ï¼Œæ˜¾ç¤ºæç¤º
                if (!network.isHost && walls.length === 0) {
                    ctx.fillStyle = '#ffc107';
                    ctx.font = '14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('ç­‰å¾…åœ°å›¾æ•°æ®...', canvas.width/2, canvas.height/2);
                }
            }
            
            requestAnimationFrame(gameLoop);
        }

        // ============== åˆå§‹åŒ– ==============
        initGame();
        gameLoop();
    </script>
</body>
</html>